{
  "version": 3,
  "sources": ["../packages/vite-plugin/src/index.ts"],
  "sourcesContent": ["import { extractScriptSetupContent } from '@bond/language-core';\nimport { readFileSync, readdirSync, existsSync } from 'fs';\nimport { resolve, join } from 'path';\nimport ts from 'typescript';\nimport { Plugin, ViteDevServer } from 'vite'\n\ninterface PluginConfig {\n    defaultViewsPath?: string\n}\n\nexport default function bond(options: PluginConfig = {}): Plugin {\n    const {\n        defaultViewsPath = 'resources/views',\n    } = options;\n    \n    let server: ViteDevServer;\n    const virtualModuleId = 'virtual:bond';\n    const resolvedVirtualModuleId = '\\0' + virtualModuleId;\n    \n    /**\n    * Find all .blade.php files recursively  \n    */\n    function findBladeFiles(dir: string): string[] {\n        if (!existsSync(dir)) {\n            return [];\n        }\n        \n        const files: string[] = [];\n        \n        function traverse(currentDir: string) {\n            try {\n                const items = readdirSync(currentDir, { withFileTypes: true });\n                \n                for (const item of items) {\n                    const fullPath = join(currentDir, item.name);\n                    \n                    if (item.isDirectory()) {\n                        traverse(fullPath);\n                    } else if (item.name.endsWith('.blade.php')) {\n                        files.push(fullPath);\n                    }\n                }\n            } catch (error) {\n                console.warn(`[bond] Cannot read directory ${currentDir}:`, error.message);\n            }\n        }\n        \n        traverse(dir);\n        return files;\n    }\n    \n    \n    /**\n    * Extract <script setup> content from blade file (only first one)\n    */\n    function extractScriptSetup(content: string): string | null {\n        const scriptSetupRegex = /<script\\s[^>]*\\bsetup\\b[^>]*>([\\s\\S]*?)<\\/script>/i;\n        const match = scriptSetupRegex.exec(content);\n        \n        return match ? match[1].trim() : null;\n    }\n    \n    /**\n    * Generate component name from file path\n    */\n    function generateComponentName(filePath: string): string {\n        const relativePath = filePath\n        .replace(resolve(defaultViewsPath), '')\n        .replace(/^\\//, '')\n        .replace(/\\.blade\\.php$/, '')\n        .replace(/\\//g, '.');\n        \n        return relativePath;\n    }\n    \n    /**\n    * Extract prop names from TypeScript type (including optional properties)\n    */\n    function extractPropNames(typeNode) {\n        if (!ts.isTypeLiteralNode(typeNode)) {\n            return [];\n        }\n        \n        const propNames: string[] = [];\n        \n        for (const member of typeNode.members) {\n            if (ts.isPropertySignature(member) && member.name) {\n                if (ts.isIdentifier(member.name)) {\n                    propNames.push(member.name.text);\n                }\n            }\n        }\n        \n        return propNames;\n    }\n    \n    /**\n    * Transform mount() calls and add import if needed\n    */\n    function transformMountCalls(code: string, filePath: string): string {\n        const componentName = generateComponentName(filePath);\n        \n        // Check if mount is used in the code\n        const usesMountFunction = code.includes('mount(');\n        \n        // Create TypeScript source file\n        const sourceFile = ts.createSourceFile(\n            'temp.ts',\n            code,\n            ts.ScriptTarget.ESNext,\n            true\n        );\n        \n        // Track if we made any changes\n        let hasChanges = false;\n        \n        // Transform the AST\n        const transformer = (context) => {\n            return (rootNode) => {\n                function visit(node) {\n                    // Look for mount() call expressions\n                    if (ts.isCallExpression(node) && \n                    ts.isIdentifier(node.expression) && \n                    node.expression.text === 'mount') {\n                        \n                        hasChanges = true;\n                        \n                        // Get the callback parameter (first argument)\n                        const callbackArg = node.arguments[0];\n                        \n                        if (ts.isArrowFunction(callbackArg)) {\n                            let propNames = [];\n                            \n                            // Extract prop names if callback has parameters\n                            if (callbackArg.parameters.length > 0) {\n                                const firstParam = callbackArg.parameters[0];\n                                \n                                // Extract prop names from the parameter's type annotation\n                                if (firstParam.type) {\n                                    propNames = extractPropNames(firstParam.type);\n                                }\n                            }\n                            \n                            // Create new arrow function without the type annotation\n                            const newCallback = ts.factory.createArrowFunction(\n                                callbackArg.modifiers,\n                                callbackArg.typeParameters,\n                                callbackArg.parameters.map(param => \n                                    ts.factory.createParameterDeclaration(\n                                        param.modifiers,\n                                        param.dotDotDotToken,\n                                        param.name,\n                                        param.questionToken,\n                                        undefined, // Remove type annotation\n                                        param.initializer\n                                    )\n                                ),\n                                callbackArg.type,\n                                callbackArg.equalsGreaterThanToken,\n                                callbackArg.body\n                            );\n                            \n                            // Create new mount call with component name, props array, and callback\n                            return ts.factory.createCallExpression(\n                                node.expression,\n                                node.typeArguments,\n                                [\n                                    ts.factory.createStringLiteral(componentName),\n                                    ts.factory.createArrayLiteralExpression(\n                                        propNames.map(name => ts.factory.createStringLiteral(name))\n                                    ),\n                                    newCallback\n                                ]\n                            );\n                        }\n                    }\n                    \n                    return ts.visitEachChild(node, visit, context);\n                }\n                \n                return ts.visitNode(rootNode, visit);\n            };\n        };\n        \n        // Apply the transformation\n        const result = ts.transform(sourceFile, [transformer]);\n        \n        let finalCode = code;\n        \n        if (hasChanges) {\n            // Print the transformed AST back to code\n            const printer = ts.createPrinter();\n            finalCode = printer.printFile(result.transformed[0]);\n        }\n        \n        result.dispose();\n        \n        // Add import only if mount function is used\n        if (usesMountFunction) {\n            const importStatement = \"import { mount } from 'bond';\\n\\n\";\n            finalCode = importStatement + finalCode;\n        }\n        \n        return finalCode;\n    }\n    \n    /**\n    * Parse blade script request\n    */\n    function parseBladeRequest(id: string) {\n        const [filename] = id.split('?', 2);\n        return { filename };\n    }\n    \n    /**\n    * Check if this is a blade script request\n    */\n    function isBladeScriptRequest(id: string) {\n        return id.includes('?bond');\n    }\n    \n    /**\n    * Setup file watcher for blade files\n    */\n    function setupWatcher() {\n        function handleFileChange(filePath: string) {\n            if (server) {                \n                // Find and invalidate the corresponding virtual .ts?bond module\n                const cleanPath = filePath.replace(/\\.blade\\.php$/, '');\n                const virtualScriptPath = `${cleanPath}.ts?bond`;\n                const scriptModule = server.moduleGraph.getModuleById(virtualScriptPath);\n\n                if (scriptModule) {\n                    server.reloadModule(scriptModule);\n                }\n            }\n        }\n        \n        server.watcher.on('change', handleFileChange)    \n        server.watcher.on('add', handleFileChange)    \n        server.watcher.on('unlink', handleFileChange)\n    }\n    \n    return {\n        name: 'vite-bond-plugin',\n        \n        configureServer(devServer) {\n            server = devServer;\n            \n            setupWatcher()\n        },\n        \n        buildStart() {\n            // During build, automatically discover and add blade files to the build\n            const bladeFiles = findBladeFiles(resolve(defaultViewsPath));\n            \n            for (const filePath of bladeFiles) {\n                try {\n                    const content = readFileSync(filePath, 'utf-8');\n                    const script = extractScriptSetup(content);\n                    \n                    if (script) {\n                        this.addWatchFile(filePath);\n                    }\n                } catch (error) {\n                    console.warn(`[bond] Error processing ${filePath}:`, error.message);\n                }\n            }\n        },\n        \n        resolveId(id) {\n            // Handle the main virtual module\n            if (id.startsWith(virtualModuleId)) {\n                return '\\0' + id;\n            }\n            \n            // Handle bond module alias\n            if (id === 'bond') {\n                return resolve(process.cwd(), 'vendor/ganyicz/bond/dist/mount.js');\n            }\n            \n            // Handle blade script requests similar to Vue's approach\n            if (isBladeScriptRequest(id)) {\n                return id; // Return as-is, we'll handle it in load\n            }\n            return null;\n        },\n        \n        load(id) {\n            // Handle the main virtual module that imports all blade scripts\n            if (id.startsWith(resolvedVirtualModuleId)) {\n                const bladeFiles = findBladeFiles(resolve(id.slice(resolvedVirtualModuleId.length + 1) || defaultViewsPath));\n                const imports: string[] = [];\n                \n                for (const filePath of bladeFiles) {\n                    try {\n                        const content = readFileSync(filePath, 'utf-8');\n                        const script = extractScriptSetup(content);\n                        \n                        if (script) {\n                            // Create a .ts virtual file so Vite handles TypeScript transformation\n                            // Remove .blade.php and add .ts extension\n                            const cleanPath = filePath.replace(/\\.blade\\.php$/, '');\n                            const virtualPath = `${cleanPath}.ts?bond`;\n                            imports.push(`import '${virtualPath}';`);\n                        }\n                    } catch (error) {\n                        console.warn(`[bond] Error processing ${filePath}:`, error.message);\n                    }\n                }\n                \n                const moduleContent = imports.length > 0 \n                ? imports.join('\\n') \n                : '// No blade script setup blocks found';\n                \n                return moduleContent;\n            }\n            \n            // Handle blade script requests\n            if (isBladeScriptRequest(id)) {\n                const { filename } = parseBladeRequest(id);\n                \n                try {\n                    // Remove the .ts extension and add back .blade.php to get the actual file\n                    const actualFilename = filename.replace(/\\.ts$/, '.blade.php');\n                    \n                    const content = readFileSync(actualFilename, 'utf-8');\n                    const script = extractScriptSetup(content);\n                    \n                    if (script) {\n                        // Transform mount() calls before returning\n                        const transformedScript = transformMountCalls(script, actualFilename);\n                        return transformedScript;\n                    } else {\n                        console.warn(`[bond] No script setup found in ${actualFilename}`);\n                        return 'export {};'; // Empty module\n                    }\n                } catch (error) {\n                    console.error(`[bond] Error loading blade script ${filename}:`, error.message);\n                    return 'export {};'; // Empty module fallback\n                }\n            }\n            \n            return null;\n        },\n        \n        transform(_, id) {\n            // Transform main blade files to import their script setup content\n            if (id.endsWith('.blade.php') && !isBladeScriptRequest(id)) {\n                try {\n                    const content = readFileSync(id, 'utf-8');\n                    const script = extractScriptSetup(content);\n                    \n                    if (script) {\n                        // Generate import for the script setup block\n                        const importStatement = `import '${id}.ts?bond';`;\n                        \n                        // Return the import as the module content\n                        return {\n                            code: importStatement,\n                            map: null\n                        };\n                    }\n                } catch (error) {\n                    console.warn(`[bond] Error transforming blade file ${id}:`, error.message);\n                }\n            }\n            \n            return null;\n        },\n    };\n}\n"],
  "mappings": "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",
  "names": []
}
